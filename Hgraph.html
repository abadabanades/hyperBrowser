<!DOCTYPE html>
<html>
<head>
    <title>Scalable Hyperbolic Graph</title>
    <script type="text/javascript" src="HGraph.js"></script>    
    <script type="text/javascript" src="js/three.js"></script>
    <script type="text/javascript" src="js/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src='js/threex.rendererstats.js'></script>
    <script type="text/javascript" src="js/dat.gui.js"></script>
    <script type="text/javascript" src="js/math.js"></script>
    <style>
        body{margin: 0; overflow: hidden;}
        #content{overflow: hidden;}
        #output{width: 70%;float:left;}
        #interaction{width: 30%;float:right;}
        
        }
</style>
    </style>
</head>
<body>
<div id="stats">
</div>
<div id="numberOfNodes">
</div>
<div id="content">
    <div id="output">
    </div>
    <br style="clear:both;"/>
    <div id="interaction">
    </div>
</div>
<script type="text/javascript">
  $(function () {
  	//create a random graph or import a graph
  	var MAX_CHILDREN_PER_NODE = 4;
  	var MIN_CHILDREN_PER_NODE = 2;
  	var DEPTH_LEVEL = 8;
  	var hgraph = createRandomGraph(MAX_CHILDREN_PER_NODE,MIN_CHILDREN_PER_NODE,DEPTH_LEVEL);
  	console.log("random graph, number of nodes: "+hgraph.vertices.length);
    
    // Align top-right
    document.getElementById('numberOfNodes').innerHTML = "Number of nodes drawn: "+hgraph.vertices.length;
    document.getElementById('numberOfNodes').style.position = 'absolute';
    document.getElementById('numberOfNodes').style.right = '0px';
    document.getElementById('numberOfNodes').style.top = '0px';
    $("#numberOfNodes").append( numberOfNodes.domElement );

    //console.log(hgraph.vertices);

  	//Outer limit of the representation area
  	var radius = 4000;

    var system;

  	//Create camera
  	var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000);
    //Create material for edges
    var edgesMaterial = new THREE.LineBasicMaterial({color:0xaaaa00});

  	//create array of spheres to easily interact with them
    var spheres = [];
    //create target of objects for detecting when clicked
    var targetMesh = [];
    
    //set the scene to play with Three.js
  	var scene = initScene(radius);

  	//load the library math.js to ease work with complex numbers
    var math = mathjs();

    //add listener to allow clickable objects
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('resize', onWindowResize, false );

    //define the material (random colour) and geometry that the vertices will have
    //var vertexGeo = new THREE.SphereGeometry(75,10,10);
    //var vertexMat = new THREE.MeshBasicMaterial({color: Math.random()*0xffffff,opacity:1});

    //draw the desired graph
    drawGraph(hgraph);
    //console.log("number of spheres drawn: "+spheres.length);
    //console.log(scene.children.length);
    //console.log(scene);

    //delete the graph
    function deleteGraph(){
        scene.traverse (function (object){
            if (object instanceof THREE.Line){
                scene.remove(object);
            }
            if (object instanceof THREE.Mesh){
                scene.remove(object);
            }
        });
        var materialC = new THREE.LineBasicMaterial({color: 0x000000});
        var geometryC = new THREE.CircleGeometry(radius,64);
        geometryC.vertices.shift(); // Remove center vertex
        scene.add(new THREE.Line(geometryC,materialC));
    }

    //draw the initial Graph
    function drawGraph(graph){
    	//to modify this DEPTH_LEVEL for a method to find it out in the given graph
    	var distance = radius*0.96 / DEPTH_LEVEL;
    	var maxDeepen = DEPTH_LEVEL;

    	
        //Create the geometry and material for the particle system
        var geom = new THREE.Geometry();
        var material = new THREE.PointCloudMaterial({size: 400,vertexColors: true,});

        var particle = new THREE.Vector3(0,0,0);
        geom.vertices.push(particle);
        geom.colors.push(new THREE.Color(new THREE.Color(Math.random()*0xffffff)));

        //var particle = new THREE.Particle(material);
        //particle.position.set(0, 0, 0);
        //scene.add(particle);

        //draw first sphere, node 0
    	//spheres[0] = new THREE.Mesh(vertexGeo,vertexMat);
        // spheres[0].position.x=0;
        // spheres[0].position.y=0;
        // scene.add(spheres[0]);
        // targetMesh.push(spheres[0]);

        //calculate angle corresponding each child
        var angle = (2*math.pi)/(graph.vertices[0].links.length)
        //console.log("angulo del primer nivel: "+angle);
        //number where to start      
        var iter = math.complex({r:1,phi:-angle/2});
        //complex number to multiply to get desired 
        var trans = math.complex({r:1,phi:angle});
        
        for (var i=0 ; i<graph.vertices[0].links.length ; i++){
        	drawChild(graph.vertices[0].links[i].id,1,iter,angle,particle.x,particle.y);
        	iter = math.multiply(iter,trans);
        }

        system = new THREE.PointCloud(geom, material);
        console.log(system);
        scene.add(system);


        function drawChild(hijo,prof,iteration,angle,positionX,positionY){
        	posX = (distance*prof)*iteration.re;
	       	posY = (distance*prof)*iteration.im;
        	if (prof++ <= maxDeepen){
        	   	//id of the processing vertex
				var id = graph.vertices[hijo].id;
                //var vertexMat = new THREE.MeshBasicMaterial({color: Math.random()*0xffffff,opacity:1});
                
                var particle = new THREE.Vector3(posX, posY, 0);
                geom.vertices.push(particle);
                geom.colors.push(new THREE.Color(Math.random()*0xffffff));


                //var particle = new THREE.Particle(material);
                //particle.position.set(posX, posY, 0);
                //scene.add(particle);


	        	//spheres[id] = new THREE.Mesh(vertexGeo,vertexMat);
	        	//spheres[id].position.x = posX;
	       		//spheres[id].position.y = posY;
	       		//spheres[id].name ="My id is: "+id;
                //(un)comment next line to (un)show balls for nodes
	       		//scene.add(spheres[id]);
	       		//targetMesh.push(spheres[id]);

	       	    var position3D = new THREE.Vector3(positionX,positionY,0);
                //if (prof <= 5)
	       		    drawEdge(position3D,particle);

	       		//calculate angle corethrsponding each child
		        var subangle = (angle)/(graph.vertices[hijo].links.length);	        
		        //number where to start      
		        var inicio = math.multiply(iteration,math.complex({r:1,phi:-angle/2}));
                inicio = math.multiply(inicio,math.complex({r:1,phi:subangle/2}));

		        //complex number to multiply to get desired 
		        var transform = math.complex({r:1,phi:subangle});       		
       		
       			for (var i=0 ; i<graph.vertices[hijo].links.length ; i++){
   			  		drawChild(graph.vertices[hijo].links[i].id,prof,inicio,subangle,particle.x,particle.y);
   			 		inicio = math.multiply(inicio,transform);
        		}
    		}
    	}

    	//draw a line between two positions (expressed in THREE.Vector3)
    	function drawEdge(vertex1, vertex2){
    		var edgesGeometry = new THREE.Geometry();
            edgesGeometry.vertices.push(vertex1);
            edgesGeometry.vertices.push(vertex2);
            edge = new THREE.Line(edgesGeometry,edgesMaterial);
            scene.add(edge);
    	}
    }

  	//Initialise the scene
  	function initScene(radius){
  		//initialise the stats, to check performance
		var stats = initStats();
        var rendererStats   = new THREEx.RendererStats()
        rendererStats.domElement.style.position = 'absolute'
        rendererStats.domElement.style.left = '0px'
        rendererStats.domElement.style.bottom   = '0px'
        document.body.appendChild( rendererStats.domElement )

		//create the scene, where all the objects are added
        var scene = new THREE.Scene();
        //point the camera to the center
        camera.position.z = 10000;
        camera.lookAt(scene.position);
        //add a circle to see the representation area
        var materialC = new THREE.LineBasicMaterial({color: 0x000000});
        var geometryC = new THREE.CircleGeometry(radius,64);
        geometryC.vertices.shift(); // Remove center vertex
        scene.add(new THREE.Line(geometryC,materialC));
        // create a renderer and set the size
        var renderer = new THREE.WebGLRenderer({alpha: true});
        renderer.setClearColor(0xEEEEEE, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoUpdateObjects = false;
        //append the renderer to the page
        $("#output").append(renderer.domElement);
        //we ask for a frame draw
        requestAnimationFrame(render);
       
        return scene;
        //function to initialise the stats for performance purposes
		function initStats() {
            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms
            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';
            $("#stats").append( stats.domElement );
            return stats;
        }
        //function render that establishes what's done in every iteration
        function render() {
            stats.update();
            rendererStats.update(renderer);

            //if (isRunning) requestAnimationFrame(render);
            //requestAnimationFrame(render);
            renderer.render(scene,camera);
        }
  	}

  	var projector = new THREE.Projector();
    var tube;
    function onDocumentMouseDown(event) {
        event.preventDefault();
        var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
        projector.unprojectVector(vector, camera);

        var raycaster = new THREE.Raycaster()

        raycaster.ray.set(camera.position, vector.sub(camera.position).normalize());

        var intersects = raycaster.intersectObject(system);

        console.log(intersects);

        if (intersects.length > 0) { 
            console.log(intersects[0].index);  
            console.log("hola");
        }
    }

    /**function OnMouseMove(evt) {
        // do some transform update on object

        // after done updating - draw!
        draw();
    }*/

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

    }


	//Function that creates a random Graph (to be modified when DB available)
    function createRandomGraph(maxChildren,minChildren,depthLevel) {
    	//Create the HGraph
    	var graph = new HGraph();
    	var depth = depthLevel;
    	console.log("Creating graph with depth: "+depth);
    	//Create first vertex and add it to the HGraph
    	var id = 0;
    	var vertex = new Vertex(id);
    	graph.vertices.push(vertex);
    	id++;    	
    	//Add some vertices (and links) to the Graph
	  	var numChildren = Math.floor(Math.random() * (maxChildren-minChildren+1) + minChildren);
    	for (var i=0 ; i<numChildren ; i++){
    		addChild(vertex,depth-1);
       	}
    	//add a vertex and link between parent and it
    	function addChild(parent,prof){
    		if (prof>=0){
	    		var vertix = new Vertex(id);
	    		graph.addVertex(vertix,parent);
	    		id++;
	    		var numiChildren = Math.floor(Math.random() * (maxChildren-minChildren+1) + minChildren);
    			for (var i=0 ; i<numiChildren ; i++){
    				addChild(vertix,prof-1);                    
    			}
    		}
    	}
        //console.log(graph.vertices);	
    	return graph;
    }
  });
</script>
</body>
</html>