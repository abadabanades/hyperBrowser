<!DOCTYPE html>
<html>
<head>
    <title>Scalable Hyperbolic Graph</title>
    <script type="text/javascript" src="HGraph.js"></script>    
    <script type="text/javascript" src="js/three.js"></script>
    <script type="text/javascript" src="js/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src='js/threex.rendererstats.js'></script>
    <script type="text/javascript" src="js/dat.gui.js"></script>
    <script type="text/javascript" src="js/math.js"></script>
    <script type="text/javascript" src="js/tween.min.js"></script>
    <script type="text/javascript" src="js/OrbitControls.js"></script>
    <style>
        body{
            margin: 0;
            overflow: hidden;
        }
        #content{
            margin: 0;
            overflow:hidden;
        }         
    </style>
</head>
<body>
<div id="content">    
    <div id="stats">
    </div>
    <div id="numberOfNodes">
    </div>
    <div id="output">
    </div>
    <div id="clicked">
    </div>
    <div id="rendererStats">
    </div>
</div>
<script type="text/javascript">
  $(function () {

    //load the library math.js to ease work with complex numbers
    var math = mathjs();

  	//outer limit of the representation area
  	var radius = 4000;
    //variables for the size of the proper representation area
    var graphWidthArea,graphHeigthArea;

    //system of points (particles), what is represented
    var system;

    //history of nodes clicked, to add back/forward functionality
    var history = [];

    //array for manipulating the lines
    var lines = [];
    var linesZiel = [];

    //create material for edges
    var edgesMaterial = new THREE.LineBasicMaterial({color:0xaaaa00,linewidth:1});
    
    //initialise the stats, to check performance-------------------------------
    var stats = new Stats();
    stats.setMode(0); // 0: fps, 1: ms
    // Align top-left
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    $("#stats").append( stats.domElement );
    var rendererStats   = new THREEx.RendererStats()
    rendererStats.domElement.style.position = 'absolute'
    rendererStats.domElement.style.left = '0px'
    rendererStats.domElement.style.bottom   = '0px'
    //document.body.appendChild( rendererStats.domElement )
    $("#rendererStats").append( rendererStats.domElement );

    //create the scene, where all the objects are added
    var scene = new THREE.Scene();

    //create camera
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth/ window.innerHeight, 0.1, 100000);
    //point the camera to the center (related to DISTANCE)
    camera.position.z = 10000;
    camera.lookAt(scene.position);


    //add a circle to see the representation area
    var materialC = new THREE.LineBasicMaterial({color: 0x000000});
    var geometryC = new THREE.CircleGeometry(radius,64);
    geometryC.vertices.shift(); // Remove center vertex
    var outsideCircle = new THREE.Line(geometryC,materialC);
    outsideCircle.name = "outside";
    scene.add(outsideCircle);

    //create a random graph or import a graph
    var MAX_CHILDREN_PER_NODE = 3;
    var MIN_CHILDREN_PER_NODE = 2;
    var DEPTH_LEVEL = 4;
    var hgraph = createRandomGraph(MAX_CHILDREN_PER_NODE,MIN_CHILDREN_PER_NODE,DEPTH_LEVEL);
    //var hgraph = importGraph("/path/to/graph/");
    //console.log("random graph, number of nodes: "+hgraph.vertices.length);

    //draw the desired graph
    drawGraph();
    //console.log(scene.children.length);
    //console.log(scene);

    // create a renderer and set the size
    var renderer = new THREE.WebGLRenderer({alpha: true});
    renderer.setClearColor(0xCCCCCC, 1.0);
    //renderer.setSize(WIDTH,HEIGHT)
    //graphWidthArea = window.innerHeight+window.innerHeight/3;
    graphWidthArea = window.innerWidth;
    graphHeigthArea = window.innerHeight;
    renderer.setSize(graphWidthArea, graphHeigthArea);
    renderer.autoUpdateObjects = false;
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    
    //append the renderer to the page
    $("#output").append(renderer.domElement);


    //we ask for a frame draw
    requestAnimationFrame(render);

    //function render that establishes what's done in every iteration
    function render() {
        stats.update();
        TWEEN.update();
        controls.update();
        rendererStats.update(renderer);
        system.geometry.colorsNeedUpdate = true;
        system.geometry.verticesNeedUpdate = true;
        for (var i = 0 ; i < lines.length ; i++){
            lines[i].geometry.verticesNeedUpdate = true;

        }
        //if (isRunning) //controls rendering process throug variable
        requestAnimationFrame(render);
        renderer.render(scene,camera);
    }

    //draw the initial Graph
    function drawGraph(){
    	//to modify this DEPTH_LEVEL for a method to find it out in the given graph
    	var distance = radius*0.96 / DEPTH_LEVEL;
    	var maxDeepen = DEPTH_LEVEL;    	
        //create the geometry and material for the particle system
        var geom = new THREE.Geometry();
        var material = new THREE.PointCloudMaterial({size:400,vertexColors:true});
        //create first particle, centered in the middle
        var particle = new THREE.Vector3(0,0,0);
        hgraph.vertices[0].position = particle;
        var particleColor =  new THREE.Color(Math.random()*0xffffff);
        geom.vertices.push(particle);
        geom.colors.push(particleColor);
        //calculate angle corresponding each child
        var angle = (2*math.pi)/(hgraph.vertices[0].linksTo.length)
        //number where to start      
        var iter = math.complex({r:1,phi:-angle/2});
        //complex number to multiply to get desired 
        var trans = math.complex({r:1,phi:angle});
        //draw all the linked nodes to the initial node
        for (var i=0 ; i<hgraph.vertices[0].linksTo.length ; i++){
        	drawChild(hgraph.vertices[0].linksTo[i].id,1,iter,angle,particle.x,particle.y);
        	iter = math.multiply(iter,trans);
        }
        //subfunction for drawing recursively every child (linked node)
        function drawChild(hijo,prof,iteration,angle,positionX,positionY){
        	posX = (distance*prof)*iteration.re;
	       	posY = (distance*prof)*iteration.im;
            prof++;
    	   	//id of the processing vertex
			var id = hgraph.vertices[hijo].id;
            //create the particle in the desired position
            var particle = new THREE.Vector3(posX, posY, 0);
            //associate particle position to the graph
            hgraph.vertices[id].position = particle;
            geom.vertices.push(particle);
            geom.colors.push(new THREE.Color(Math.random()*0xffffff));
            //geom.colors.push(particleColor);
       	    var position3D = new THREE.Vector3(positionX,positionY,0);
            //if (prof <= 5)
       		  drawEdge(particle,position3D);

       		//calculate angle corethrsponding each child
	        var subangle = (angle)/(hgraph.vertices[hijo].linksTo.length);
	        //number where to start      
	        var inicio = math.multiply(iteration,math.complex({r:1,phi:-angle/2}));
            inicio = math.multiply(inicio,math.complex({r:1,phi:subangle/2}));
	        //complex number to multiply to get desired 
	        var transform = math.complex({r:1,phi:subangle});       		
   		    //draw all the linked nodes tproo this node
   			for (var i=0 ; i<hgraph.vertices[hijo].linksTo.length ; i++){
			  		drawChild(hgraph.vertices[hijo].linksTo[i].id,prof,inicio,subangle,particle.x,particle.y);
			 		inicio = math.multiply(inicio,transform);
    		}
    	}

        for (var i = 0 ; i < lines.length ; i++){
            scene.add(lines[i]);
        }
        history.push(0);
        system = new THREE.PointCloud(geom, material);
        system.name = "system";
        scene.add(system);

    	//draw a line between two positions (expressed in THREE.Vector3)
    	function drawEdge(vertex1, vertex2){
    		var edgesGeometry = new THREE.Geometry();
            edgesGeometry.vertices.push(vertex1);
            edgesGeometry.vertices.push(vertex2);
            edge = new THREE.Line(edgesGeometry,edgesMaterial);
            lines.push(edge);
    	}
    }

    //function reDrawGraph
    //@param newCenter id of the node to put in the center
    function reDrawGraph(newCenter){
        //console.log("id del nodo a centrar: "+newCenter);
        var newGraph = hgraph;

        //var newDepth = DEPTH_LEVEL;
        var newDepth = calculateNewDepth(newCenter);

        function calculateNewDepth(novi){
            //var copyGraph = newGraph;
            var maximumDepth = 0;
            for (var i = 0 ; i < newGraph.vertices.length ; i++) {  
                newGraph.vertices[i].processed=false;
            }
            newGraph.vertices[novi].processed=true;
            var links = linksNoProcessed(novi);
            for (var i=0 ; i<links.length ; i++){
                processChild(links[i].id,0);
            }
            function processChild(ide,prof){
                if (++prof >= maximumDepth){
                    maximumDepth = prof;
                }
                var id = newGraph.vertices[ide].id;
                newGraph.vertices[id].processed = true;

                var links = linksNotProcessed(id);
                for (var i=0 ; i<links.length ; i++){
                    processChild(links[i].id,prof);
                }
            }
            function linksNoProcessed(ide){
                var links = [];
                for (var i = 0 ; i < newGraph.vertices[ide].linksTo.length ; i++) {
                    if (! newGraph.vertices[ide].linksTo[i].processed){
                        links.push(newGraph.vertices[ide].linksTo[i]);
                    }
                }
                for (var i = 0 ; i < newGraph.vertices[ide].linksFrom.length ; i++) {
                    if (! newGraph.vertices[ide].linksFrom[i].processed){
                        links.push(newGraph.vertices[ide].linksFrom[i]);
                    }
                }
                return links;
            }
            return maximumDepth;
        }

        //to modify this DEPTH_LEVEL for a method to find it out in the given graph
        var distance = radius*0.96 / newDepth;
        var maxDeepen = newDepth;


        for (var i = 0 ; i < newGraph.vertices.length ; i++) {  
            newGraph.vertices[i].processed = false;
        }

        newGraph.vertices[newCenter].position.x=0;
        newGraph.vertices[newCenter].position.y=0;
        newGraph.vertices[newCenter].processed=true;
        
        var links = linksNotProcessed(newCenter);
        
        //calculate angle corresponding each child
        //if (newGraph.vertices[newCenter].linksTo.length = 0)
            var angle = (2*math.pi)/(links.length);
        
        //number where to start      
        var iter = math.complex({r:1,phi:-angle/2});
        //complex number to multiply to get desired 
        var trans = math.complex({r:1,phi:angle});

        var linesIteration = 0;

        //draw all the linked nodes to the initial node
        for (var i=0 ; i<links.length ; i++){
            updateChild(links[i].id,1,iter,angle,0,0);
            iter = math.multiply(iter,trans);
        }

        return newGraph;

        //subfunction for updating recursively every child (linked node)
        function updateChild(hijo,prof,iteration,angle,positionX,positionY){
            posX = (distance*prof)*iteration.re;
            posY = (distance*prof)*iteration.im;
            prof++;
            //id of the processing vertex
            var id = hgraph.vertices[hijo].id;            
            //associate particle position to the graph
            newGraph.vertices[id].position = new THREE.Vector3(posX, posY, 0);
            newGraph.vertices[id].processed = true;

            var position3D = new THREE.Vector3(positionX,positionY,0);
            var positionSon = newGraph.vertices[id].position;

            updateEdge();
            function updateEdge(){
                //if (prof <= 5)
                  //drawEdge(position3D,positionSon);
                //linesZiel[linesIteration] = position3D;
                lines[linesIteration].geometry.vertices[0] = position3D;
                lines[linesIteration].geometry.vertices[1] = positionSon;
                linesIteration++;
            }

            //calculate angle corresponding each child
            var links = linksNotProcessed(id);
            var subangle = (angle)/(links.length);
            //number where to start      
            var inicio = math.multiply(iteration,math.complex({r:1,phi:-angle/2}));
            inicio = math.multiply(inicio,math.complex({r:1,phi:subangle/2}));
            //complex number to multiply to get desired 
            var transform = math.complex({r:1,phi:subangle});               
            //draw all the linked nodes to this node

            for (var i=0 ; i<links.length ; i++){
                updateChild(links[i].id,prof,inicio,subangle,positionSon.x,positionSon.y);
                inicio = math.multiply(inicio,transform);
            }
        }

        //function that gives me an array with the ids of node linked to a node
        //that have not been previously processed (drawn)
        function linksNotProcessed(id){
            var links = [];
            for (var i = 0 ; i < newGraph.vertices[id].linksTo.length ; i++) {
                if (! newGraph.vertices[id].linksTo[i].processed){
                    links.push(newGraph.vertices[id].linksTo[i]);
                }
            }
            for (var i = 0 ; i < newGraph.vertices[id].linksFrom.length ; i++) {
                if (! newGraph.vertices[id].linksFrom[i].processed){
                    links.push(newGraph.vertices[id].linksFrom[i]);
                }
            }
            return links;
        }
    }

        /**console.log(system.geometry.vertices[newCenter]);
        system.geometry.vertices[0].set(system.geometry.vertices[newCenter].x,
                                        system.geometry.vertices[newCenter].y,
                                        system.geometry.vertices[newCenter].z);
        system.geometry.vertices[newCenter].set(0,0,0);*/

    //delete the graph
    /**function deleteGraph(){
        scene.traverse (function (object){
            if (object instanceof THREE.Line){
                scene.remove(object);
            }
            if (object instanceof THREE.Mesh){
                scene.remove(object);
            }
        });
        var materialC = new THREE.LineBasicMaterial({color: 0x000000});
        var geometryC = new THREE.CircleGeometry(radius,64);
        geometryC.vertices.shift(); // Remove center vertex
        scene.add(new THREE.Line(geometryC,materialC));
    }*/

    //information about number of nodes drawn. Align top-right
    document.getElementById('numberOfNodes').innerHTML = "Number of nodes drawn: "+hgraph.vertices.length;
    document.getElementById('numberOfNodes').style.position = 'absolute';
    document.getElementById('numberOfNodes').style.right = '10px';
    document.getElementById('numberOfNodes').style.top = '10px';
    $("#numberOfNodes").append( numberOfNodes.domElement );

    //information about interaction with nodes. Align bottom-right
    document.getElementById('clicked').innerHTML = "No interaction until now";
    document.getElementById('clicked').style.position = 'absolute';
    document.getElementById('clicked').style.right = '10px';
    document.getElementById('clicked').style.bottom = '10px';
    $("#clicked").append( clicked.domElement );

    //------------------------LISTENERS--------------------------
    //add listener to allow clickable objects
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    //add listener for resizing window
    document.addEventListener('resize', onWindowResize, false );
    //add listener for moving mouse
    document.addEventListener('mousemove', onDocumentMouseMove, false );

    //print the properties of a node  if is clicked and bring it to the center
    function onDocumentMouseDown(event) {
        event.preventDefault();
        //check if some node clicked, for displaying information
        var projector = new THREE.Projector();
        var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
        projector.unprojectVector(vector, camera);
        var raycaster = new THREE.Raycaster();
        raycaster.params.PointCloud.threshold = 90;
        raycaster.ray.set(camera.position, vector.sub(camera.position).normalize());
        var intersects = raycaster.intersectObject(system);        
        if (intersects.length > 0) {
            document.getElementById('clicked').innerHTML = "Clicked node: "+intersects[0].index;
            var recalculatedGraph = reDrawGraph(intersects[0].index);
            history.push(intersects[0].index);
            console.log(history);

            //for (var i = 0 ; i < recalculatedGraph.vertices.length ; i++) {
                //system.geometry.vertices[i] = recalculatedGraph.vertices[i].position;
            //}
        
            hgraph = recalculatedGraph;

            // create a tween
            // http://sole.github.io/tween.js/examples/03_graphs.html
            
            var posSrc = {tmp: 150}
            var tween = new TWEEN.Tween(posSrc).to({tmp: 1}, 1000);
            //to choose between transitions
            tween.easing(TWEEN.Easing.Sinusoidal.InOut);

            var onUpdate = function () {
                var count = 0;
                var tmp = this.tmp;

                system.geometry.vertices.forEach(function (e) {
                    var newX = ((e.x)+((recalculatedGraph.vertices[count].position.x-e.x)/tmp));
                    var newY = ((e.y)+((recalculatedGraph.vertices[count].position.y-e.y)/tmp));
                    system.geometry.vertices[count++].set(newX, newY, e.z);
                });

                system.sortParticles = true;
            };

            tween.onUpdate(onUpdate);

            tween.start();

            /*for (var i = 0 ; i<= lines.length ; i++){
                lines[i].geometry.vertices[1] = linesZiel[i];
            }*/
        }
    }

    var intersectedNode;
    var originalColor = new THREE.Color();
    var mouseOver = false;

    //highlighting a node if mouse is over
    function onDocumentMouseMove(event) {
        event.preventDefault();
        //check if some node clicked, for displaying information
        var projector = new THREE.Projector();
        var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
        projector.unprojectVector(vector, camera);
        var raycaster = new THREE.Raycaster();
        raycaster.params.PointCloud.threshold = 90;
        raycaster.ray.set(camera.position, vector.sub(camera.position).normalize());
        var intersects = raycaster.intersectObject(system);
        if (intersects.length > 0) {
            if (!mouseOver){
                var color = system.geometry.colors[intersects[0].index];
                originalColor.setRGB(color.r,color.g,color.b);
                intersectedNode = intersects[0].index;                
                system.geometry.colors[intersects[0].index].setRGB(1,1,1);
                mouseOver = true;
                document.getElementById('clicked').innerHTML = "Intersected node: "+intersects[0].index;
                document.body.style.cursor = 'pointer';
            }
        } else {
            if (mouseOver){
                system.geometry.colors[intersectedNode].setRGB(originalColor.r,originalColor.g,originalColor.b);
                mouseOver = false;
                document.body.style.cursor = 'default';
            }            
        }           
    }

    //proper working when resizing window (apparently not working)
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        //controls.handleResize();
    }
  });
</script>
</body>
</html>