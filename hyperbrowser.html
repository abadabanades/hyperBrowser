<!DOCTYPE html>
<html>
<head>
    <title>Hyperbolic Browser</title>
    <script type="text/javascript" src="js/three.js"></script>
    <script type="text/javascript" src="js/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src="js/dat.gui.js"></script>
    <script type="text/javascript" src="js/Graph.js"></script>
    <script type="text/javascript" src="js/math.js"></script>

    <!--<script type="text/javascript" src="js/Label.js"></script>    
    <script type="text/javascript" src="js/ObjectSelection.js"></script>

    <script type="text/javascript" src="layout.js"></script>-->
    <style>
        body{
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
<div id="stats">
</div>
<div id="output">
</div>
<!--Javascript code-->
<script type="text/javascript">
	$(function () {
        //initialise the stats, to check performance
		var stats = initStats();

        var scene = new THREE.Scene();

        //Create the camera and point to the center
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000);
        //Modifying camera coordinates x and z we can appreciate the 3D
        camera.position.z = 10000;
        camera.lookAt(scene.position);

        //later we will import from a JSON file or similar
        var graph = createGraph(); 

        //load the library math.js to ease work with complex numbers
        var math = mathjs();

        //add a circle to see the representation area
        var radius = 4000,
        materialC = new THREE.LineBasicMaterial({color: 0x000000}),
        geometryC = new THREE.CircleGeometry(radius,64);
        geometryC.vertices.shift(); // Remove center vertex
        scene.add(new THREE.Line(geometryC,materialC));

        //axisHelper for developing purposes
        var axisHelper = new THREE.AxisHelper( 400 );
        scene.add( axisHelper );

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer({alpha: true});
        renderer.setClearColor(0xEEEEEE, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
      
        $("#output").append(renderer.domElement);

        //draw the given graph
        drawGraph(graph);
        render();

        //function that creates a random Graph (to be modified when DB available)
        function createGraph() {
            var graph = new Graph();
            var node = new Node(0);
            node.data.title = "This is node " + node.id;
            graph.addNode(node);

            var nodes = [];
            nodes.push(node);

            var steps = 1;
            while(nodes.length != 0 && steps < 6) {
              var node = nodes.shift();

              //from 1 to 20
              var numEdges = Math.floor(Math.random() * (8 - 3 + 1) + 3);;
              for(var i=1; i <= numEdges; i++) {
                var target_node = new Node(i*steps);
                if(graph.addNode(target_node)) {
                  target_node.data.title = "This is node " + target_node.id;
                  nodes.push(target_node);
                  graph.addEdge(node, target_node);
                }
              }
              steps++;
            }
            return graph;
        }

        function drawGraph(graph){

            //draw the initial node, always in the middle
            var nodeGeo = new THREE.SphereGeometry(50,10,10);
            var nodeMat = new THREE.MeshBasicMaterial({color: Math.random()*0xffffff,opacity:1});
            var sphere0 = new THREE.Mesh(nodeGeo,nodeMat);
            sphere0.position.x=0;
            sphere0.position.y=0;
            scene.add(sphere0);

            var angle = subangle(2*math.pi,graph.nodes[0].nodesTo.length)
            var a = math.complex({re:1,im:0})
            var trans = math.complex({r:1,phi:angle})

            for(var i=0; i < graph.nodes[0].nodesTo.length; i++) {
                a = math.multiply(a,trans);      
                graph.nodes[0].nodesTo[i].position.x = 2500*a.re;
                graph.nodes[0].nodesTo[i].position.y = 2500*a.im;
                console.log(graph.nodes[0].nodesTo[i]);
                var nodeMat = new THREE.MeshBasicMaterial({color: Math.random()*0xffffff,opacity:1});
                var sphere = new THREE.Mesh(nodeGeo,nodeMat);
                sphere.position.x=graph.nodes[0].nodesTo[i].position.x;
                sphere.position.y=graph.nodes[0].nodesTo[i].position.y;
                scene.add(sphere);

                drawEdge(graph.nodes[0],graph.nodes[0].nodesTo[i]);

                if (graph.nodes[0].nodesTo[i].nodesTo.length != 0){
                    drawSubWedge(graph.nodes[0].nodesTo[i],angle,graph.nodes[0].nodesTo[i].position);
                }
            }
        }

        function drawSubWedge(node,angle,position){
            var a0 = math.complex({re:1,im:0})
            var angles = subangle(2*math.pi,node.nodesTo.length)
            var trans0 = math.complex({r:1,phi:angles})
            for(var i=0; i < node.nodesTo.length; i++) {
                a0 = math.multiply(a0,trans0);;
                node.nodesTo[i].position.x = position.x + 500*a0.re;
                node.nodesTo[i].position.y = position.y + 500*a0.im;
                console.log(node.nodesTo[i]);
                var nodeGeo = new THREE.SphereGeometry(50,10,10);
                var nodeMat = new THREE.MeshBasicMaterial({color: Math.random()*0xffffff,opacity:1});
                var sphere = new THREE.Mesh(nodeGeo,nodeMat);
                sphere.position.x=node.nodesTo[i].position.x;
                sphere.position.y=node.nodesTo[i].position.y;
                scene.add(sphere);
            }
        }

        function transformation(z,p,theta){
            //z,p,theta are complex numbers
            var num = math.add(math.multiply(theta,z),p);
            var den = math.add(1,math.multiply(math.multiply(math.conj(p),theta),z))
            var zz = math.divide(num,den);
            return zz;
        };

        function inversetransformation(z,p,theta){
            var p0,t0;
            return transformation(z,p0,t0);
        };

        function composition(z,p1,t1,p2,t2){
            var p0,t0;
            return transformation(z,p0,t0);
        };

        function distance(s,a){
            var sum1 = math.sqrt((Math.pow((4/2),2))+5);
            var sum2 = 0;
            return 0;
        }

        function subangle(angle,numberOfChildren){
            return angle / numberOfChildren;
        }

        function subangleLogarithm(angle,node){
            return 0;
        }

        function drawEdge(source, target) {
            material = new THREE.LineBasicMaterial({ color: 0xff0000, opacity: 1, linewidth: 0.5 });

            var tmp_geo = new THREE.Geometry();
            tmp_geo.vertices.push(source.position);
            tmp_geo.vertices.push(target.position);

            line = new THREE.Line( tmp_geo, material, THREE.LinePieces );
            line.scale.x = line.scale.y = line.scale.z = 1;
            line.originalScale = 1;

            scene.add( line );
        }

        function subangle(angle,numberOfChildren){
            return angle / numberOfChildren;
        }

        //function render that establishes what's done in every iteration
        function render() {
            stats.update();
            // render using requestAnimationFrame
            requestAnimationFrame(render);
            renderer.render(scene,camera);
        }

        //function to initialise the stats for performance purposes
		function initStats() {
            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms
            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';
            $("#stats").append( stats.domElement );
            return stats;
        }
	});
</script>
</body>
</html>