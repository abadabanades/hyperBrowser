<!DOCTYPE html>
<html>
<head>
    <title>Hyperbolic Browser</title>
    <script type="text/javascript" src="js/three.js"></script>
    <script type="text/javascript" src="js/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src="js/dat.gui.js"></script>
    <script type="text/javascript" src="js/Graph.js"></script>
    <script type="text/javascript" src="js/math.js"></script>

    <!--<script type="text/javascript" src="js/Label.js"></script>    
    <script type="text/javascript" src="js/ObjectSelection.js"></script>

    <script type="text/javascript" src="layout.js"></script>-->
    <style>
        body{
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
<div id="stats">
</div>
<div id="output">
</div>
<!--Javascript code-->
<script type="text/javascript">
	$(function () {
        //initialise the stats, to check performance
		var stats = initStats();

        //create the scene, where all the objects are added
        var scene = new THREE.Scene();

        //Create the camera and point to the center
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000);
        camera.position.z = 10000;
        camera.lookAt(scene.position);

        //later we will import from a JSON file or similar
        var graph = createGraph();

        //load the library math.js to ease work with complex numbers
        var math = mathjs();

        //add a circle to see the representation area
        var radius = 4000,
        materialC = new THREE.LineBasicMaterial({color: 0x000000}),
        geometryC = new THREE.CircleGeometry(radius,64);
        geometryC.vertices.shift(); // Remove center vertex
        scene.add(new THREE.Line(geometryC,materialC));

        //axisHelper for developing purposes
        //var axisHelper = new THREE.AxisHelper( 400 );
        //scene.add( axisHelper );

        // create a renderer and set the size
        var renderer = new THREE.WebGLRenderer({alpha: true});
        renderer.setClearColor(0xEEEEEE, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        //append the renderer to the page
        $("#output").append(renderer.domElement);

        //draw the loeaded graph
        drawGraph(graph);
        render();

        //function that creates a random Graph (to be modified when DB available)
        function createGraph() {
            var graph = new Graph();
            var node = new Node(0);
            node.data.title = "This is node " + node.id;
            graph.addNode(node);

            var nodes = [];
            nodes.push(node);

            var steps = 1;
            while(nodes.length != 0 && steps < 20) {
              var node = nodes.shift();

              //from 1 to 20
              var numEdges = Math.floor(Math.random() * (8 - 3 + 1) + 3);;
              for(var i=1; i <= numEdges; i++) {
                var target_node = new Node(i*steps);
                if(graph.addNode(target_node)) {
                  target_node.data.title = "This is node " + target_node.id;
                  nodes.push(target_node);
                  graph.addEdge(node, target_node);
                }
              }
              steps++;
            }
            return graph;
        }

        function drawGraph(graph){

            //draw the initial node, always in the middle (we'll look at it)
            var nodeGeo = new THREE.SphereGeometry(50,10,10);
            var nodeMat = new THREE.MeshBasicMaterial({color: Math.random()*0xffffff,opacity:1});
            var sphere0 = new THREE.Mesh(nodeGeo,nodeMat);
            sphere0.position.x=0;
            sphere0.position.y=0;
            scene.add(sphere0);

            //distance to the center for first level of nodes (should be automatic)
            var rad = 2500;

            //angle of subdivisions. Equal in first stage
            //TBI: automatic in function of number of children and grandchildren
            var angle = subangle(2*math.pi,graph.nodes[0].nodesTo.length)
            //number 1 in complex, to be used for the desplazamiento
            var a = math.complex({re:1,im:0})
            //number to multiply by a to get the desired transformation within the circumference
            var trans = math.complex({r:1,phi:angle})

            //for all the nodes children of the first node
            for(var i=0; i < graph.nodes[0].nodesTo.length; i++) {
                //calculate desplazamiento
                a = math.multiply(a,trans);
                //establish the position where it'll be drawn
                graph.nodes[0].nodesTo[i].position.x = rad*a.re;
                graph.nodes[0].nodesTo[i].position.y = rad*a.im;
                //console.log(graph.nodes[0].nodesTo[i]);
                //draw the sphere representing this node
                var nodeMat = new THREE.MeshBasicMaterial({color: Math.random()*0xffffff,opacity:1});
                var sphere = new THREE.Mesh(nodeGeo,nodeMat);
                sphere.position.x=graph.nodes[0].nodesTo[i].position.x;
                sphere.position.y=graph.nodes[0].nodesTo[i].position.y;
                scene.add(sphere);

                //draw the edge connecting parent and children
                drawEdge(sphere0.position,sphere.position);

                //if the son has children, call recursively to do same process
                if (graph.nodes[0].nodesTo[i].nodesTo.length != 0){
                    drawSubWedge(graph.nodes[0].nodesTo[i],angle,graph.nodes[0].nodesTo[i].position,rad/2);
                }
            }
        }

        //create a line between two positions
        function drawEdge(source, target) {
            material = new THREE.LineBasicMaterial({ color: 0xff0000, opacity: 1, linewidth: 3 });

            var tmp_geo = new THREE.Geometry();
            tmp_geo.vertices.push(source);
            tmp_geo.vertices.push(target);

            line = new THREE.Line( tmp_geo, material, THREE.LinePieces );
            line.scale.x = line.scale.y = line.scale.z = 1;
            line.originalScale = 1;

            scene.add( line );
        }

        function drawSubWedge(node,angle,position,dis){
            //a0 is the angle from where the wedge starts
            var a0 = math.complex({re:1,im:0})
            var angles = subangle(2*math.pi,node.nodesTo.length)
            var trans0 = math.complex({r:1,phi:angles})

            for(var i=0; i < node.nodesTo.length; i++) {
                a0 = math.multiply(a0,trans0);;
                node.nodesTo[i].position.x = position.x + dis*a0.re;
                node.nodesTo[i].position.y = position.y + dis*a0.im;
                //console.log(node.nodesTo[i]);
                var nodeGeo = new THREE.SphereGeometry(50,10,10);
                var nodeMat = new THREE.MeshBasicMaterial({color: Math.random()*0xffffff,opacity:1});
                var sphere = new THREE.Mesh(nodeGeo,nodeMat);
                sphere.position.x=node.nodesTo[i].position.x;
                sphere.position.y=node.nodesTo[i].position.y;
                scene.add(sphere);

                var position3D = new THREE.Vector3(position.x,position.y,0);
                console.log(position3D);
                console.log(sphere.position);
                drawEdge(position3D,sphere.position);

                if (node.nodesTo[i].nodesTo.length != 0){
                    drawSubWedge(node.nodesTo[i],angle,sphere.position,dis/2);
                }
            }
        }

        function transformation(z,p,theta){
            //z,p,theta are complex numbers
            var num = math.add(math.multiply(theta,z),p);
            var den = math.add(1,math.multiply(math.multiply(math.conj(p),theta),z))
            var zz = math.divide(num,den);
            return zz;
        };

        function inversetransformation(z,p,theta){
            var p0,t0;
            return transformation(z,p0,t0);
        };

        function composition(z,p1,t1,p2,t2){
            var p0,t0;
            return transformation(z,p0,t0);
        };

        function distance(s,a){
            var sum1 = math.sqrt((Math.pow((4/2),2))+5);
            var sum2 = 0;
            return 0;
        }

        function subangle(angle,numberOfChildren){
            return angle / numberOfChildren;
        }

        function subangleLogarithm(angle,node){
            return 0;
        }

        function subangle(angle,numberOfChildren){
            return angle / numberOfChildren;
        }

        //function render that establishes what's done in every iteration
        function render() {
            stats.update();
            // render using requestAnimationFrame
            requestAnimationFrame(render);
            renderer.render(scene,camera);
        }

        //function to initialise the stats for performance purposes
		function initStats() {
            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms
            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';
            $("#stats").append( stats.domElement );
            return stats;
        }
	});
</script>
</body>
</html>